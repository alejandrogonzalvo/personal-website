<canvas id="stars-canvas"></canvas>

<style>
  #stars-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
    background: transparent;
  }
</style>

<script>
  const canvas = document.getElementById('stars-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');

  let width = window.innerWidth;
  let height = window.innerHeight;
  
  canvas.width = width;
  canvas.height = height;

  const stars: Star[] = [];
  const numStars = 150; // Adjust for density
  
  // Mouse state
  let mouse = { x: -9999, y: -9999 };
  const repulsionRadius = 150;
  const repulsionStrength = 2; // Strength of the force

  window.addEventListener('mousemove', (e) => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    initStars();
  });

  class Star {
    x: number;
    y: number;
    z: number;
    size: number;
    baseX: number; // Original position for returning (optional, or just let them float)
    baseY: number; 
    vx: number;
    vy: number;
    opacity: number;

    constructor() {
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.z = Math.random() * 2 + 0.5; // Depth factor for parallax/size
      this.size = Math.random() * 2;
      this.vx = 0;
      this.vy = (Math.random() * 0.5 + 0.1) * this.z; // Falling speed based on depth
      this.opacity = Math.random() * 0.5 + 0.3;
      
      this.baseX = this.x;
      this.baseY = this.y;
    }

    update() {
      // 1. Normal Movement (Scrolling down)
      this.y -= this.vy; // Move UP to simulate scrolling down, or DOWN? 
      // Original CSS moved translateY(-2000px) which is moving stars UP.
      // So let's move them UP.
      
      // Wrap around
      if (this.y < 0) {
        this.y = height;
        this.x = Math.random() * width;
      }

      // 2. Repulsion
      const dx = this.x - mouse.x;
      const dy = this.y - mouse.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance < repulsionRadius) {
        const forceDirectionX = dx / distance;
        const forceDirectionY = dy / distance;
        
        // The closer, the stronger the force
        const force = (repulsionRadius - distance) / repulsionRadius;
        
        const directionX = forceDirectionX * force * repulsionStrength * this.z; // affect closer stars more? or less? usually close stars (higher z) move more
        const directionY = forceDirectionY * force * repulsionStrength * this.z;

        this.x += directionX;
        this.y += directionY;
      }
    }

    draw() {
      if (!ctx) return;
      ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function initStars() {
    stars.length = 0;
    for (let i = 0; i < numStars; i++) {
      stars.push(new Star());
    }
  }

  function animate() {
    if (!ctx) return;
    ctx.clearRect(0, 0, width, height);
    
    stars.forEach(star => {
      star.update();
      star.draw();
    });

    requestAnimationFrame(animate);
  }

  initStars();
  animate();
</script>
