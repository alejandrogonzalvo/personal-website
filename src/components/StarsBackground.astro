<canvas id="stars-canvas"></canvas>

<style>
  #stars-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
    background: transparent;
  }
</style>

<script>
  const canvas = document.getElementById('stars-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');

  let width = window.innerWidth;
  let height = window.innerHeight;
  
  canvas.width = width;
  canvas.height = height;

  const stars: Star[] = [];
  const temporaryStars: Star[] = []; // Array for click-generated stars
  const numStars = 150; // Adjust for density
  
  // Mouse state
  let mouse = { x: -9999, y: -9999 };
  const repulsionStrength = 2; // Strength of the force

  window.addEventListener('mousemove', (e) => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  // Click listener for Burst Effect
  window.addEventListener('mousedown', (e) => {
      // 1. Exclusion Logic
      const target = e.target as HTMLElement;
      const excludeTags = ['A', 'BUTTON', 'INPUT', 'TEXTAREA', 'SELECT', 'VIDEO', 'IMG', 'svg', 'path'];
      const closestInteractive = target.closest('a, button, .hero-card, .project-item, .contact-link, .back-link, #name-typewriter, #role-typewriter');
      
      if (closestInteractive || excludeTags.includes(target.tagName)) {
          return;
      }
      
      // 2. Generate Rising Stars
      createRisingStars(e.clientX, e.clientY);
  });

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    initStars();
  });

  class Star {
    x: number;
    y: number;
    z: number;
    size: number;
    baseX: number; 
    baseY: number; 
    vx: number;
    vy: number;
    opacity: number;
    isTemporary: boolean;

    constructor(x?: number, y?: number, isTemporary: boolean = false) {
      this.isTemporary = isTemporary;
      this.x = x !== undefined ? x : Math.random() * width;
      this.y = y !== undefined ? y : Math.random() * height;
      this.z = Math.random() * 2 + 0.5; // Depth factor for parallax/size
      this.size = Math.random() * 2;
      this.vx = 0;
      this.vy = (Math.random() * 0.5 + 0.1) * this.z; // Falling speed based on depth
      this.opacity = Math.random() * 0.5 + 0.3;
    }

    update(repulsors) {
      // 1. Normal Movement (Scrolling down/up)
      // Stars move UP to simulate scrolling down
      this.y -= this.vy; 
      
      // Wrap around ONLY for permanent stars
      if (!this.isTemporary) {
          if (this.y < 0) {
            this.y = height;
            this.x = Math.random() * width;
          }
      }

      // 2. Repulsion from all sources
      let finalDx = 0;
      let finalDy = 0;

      repulsors.forEach(repulsor => {
          const dx = this.x - repulsor.x;
          const dy = this.y - repulsor.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < repulsor.radius) {
            const forceDirectionX = dx / distance;
            const forceDirectionY = dy / distance;
            
            const force = (repulsor.radius - distance) / repulsor.radius;
            
            finalDx += forceDirectionX * force * repulsor.strength * this.z;
            finalDy += forceDirectionY * force * repulsor.strength * this.z;
          }
      });

      this.x += finalDx;
      this.y += finalDy;
    }

    draw() {
      if (!ctx) return;
      ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createRisingStars(x, y) {
      const particleCount = 20;
      const spread = 50; // How wide the initial cluster is
      
      for (let i = 0; i < particleCount; i++) {
          const randomX = x + (Math.random() - 0.5) * spread;
          const randomY = y + (Math.random() - 0.5) * spread;
          temporaryStars.push(new Star(randomX, randomY, true));
      }
  }

  function initStars() {
    stars.length = 0;
    for (let i = 0; i < numStars; i++) {
      stars.push(new Star());
    }
  }

  let cardElements = document.querySelectorAll('.hero-card, .project-item, .contact-link, .back-link, .center-container h1');
  
  function animate() {
    if (!ctx) return;
    ctx.clearRect(0, 0, width, height);

    // Prepare repulsors list for this frame
    const repulsors = [];
    
    // 1. Mouse
    if (mouse.x > 0 && mouse.y > 0) {
        repulsors.push({
            x: mouse.x,
            y: mouse.y,
            radius: 150,
            strength: repulsionStrength
        });
    }

    // 2. Cards & Elements
    if (cardElements.length === 0) {
        cardElements = document.querySelectorAll('.hero-card, .project-item, .contact-link, .back-link, .center-container h1');
    }

    cardElements.forEach(el => {
        const rect = el.getBoundingClientRect();
        if (rect.bottom < 0 || rect.top > height || rect.width === 0) return;
        const radius = Math.max(rect.width, rect.height) / 1.5;
        repulsors.push({
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
            radius: radius,
            strength: repulsionStrength
        });
    });
    
    // Update & Draw Background Stars
    stars.forEach(star => {
      star.update(repulsors);
      star.draw();
    });
    
    // Update & Draw Temporary Stars
    for (let i = temporaryStars.length - 1; i >= 0; i--) {
        const star = temporaryStars[i];
        star.update(repulsors); // They also react to repulsors!
        star.draw();
        
        // Remove if off-screen (top)
        if (star.y < -10) {
            temporaryStars.splice(i, 1);
        }
    }

    requestAnimationFrame(animate);
  }

  initStars();
  animate();
</script>
