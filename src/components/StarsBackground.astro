<canvas id="stars-canvas"></canvas>

<style>
  #stars-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
    background: transparent;
  }
</style>

<script>
  const canvas = document.getElementById('stars-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');

  let width = window.innerWidth;
  let height = window.innerHeight;
  
  canvas.width = width;
  canvas.height = height;

  const stars: Star[] = [];
  const numStars = 150; // Adjust for density
  
  // Mouse state
  let mouse = { x: -9999, y: -9999 };
  const repulsionStrength = 2; // Strength of the force

  window.addEventListener('mousemove', (e) => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    initStars();
  });

  class Star {
    x: number;
    y: number;
    z: number;
    size: number;
    baseX: number; 
    baseY: number; 
    vx: number;
    vy: number;
    opacity: number;

    constructor() {
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.z = Math.random() * 2 + 0.5; // Depth factor for parallax/size
      this.size = Math.random() * 2;
      this.vx = 0;
      this.vy = (Math.random() * 0.5 + 0.1) * this.z; // Falling speed based on depth
      this.opacity = Math.random() * 0.5 + 0.3;
    }

    update(repulsors) {
      // 1. Normal Movement (Scrolling down/up)
      // Stars move UP to simulate scrolling down
      this.y -= this.vy; 
      
      // Wrap around
      if (this.y < 0) {
        this.y = height;
        this.x = Math.random() * width;
      }

      // 2. Repulsion from all sources
      // We accumulate forces? Or just pick the strongest?
      // Accumulating forces gives smooth interaction between multiple repulsors
      
      let finalDx = 0;
      let finalDy = 0;

      repulsors.forEach(repulsor => {
          const dx = this.x - repulsor.x;
          const dy = this.y - repulsor.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < repulsor.radius) {
            const forceDirectionX = dx / distance;
            const forceDirectionY = dy / distance;
            
            // The closer, the stronger the force
            const force = (repulsor.radius - distance) / repulsor.radius;
            
            // Add to total displacement
            finalDx += forceDirectionX * force * repulsor.strength * this.z;
            finalDy += forceDirectionY * force * repulsor.strength * this.z;
          }
      });

      this.x += finalDx;
      this.y += finalDy;
    }

    draw() {
      if (!ctx) return;
      ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function initStars() {
    stars.length = 0;
    for (let i = 0; i < numStars; i++) {
      stars.push(new Star());
    }
  }

  // Cache selectors if possible, but list might be dynamic if elements added? 
  // For this site, fairly static. Querying once is safer for performance, 
  // but if components lazy load, we might miss them.
  // We'll query once and if it's empty try again?
  // Or just queryAll on every frame? It's optimized by browsers usually.
  // Let's query once and assume static structure for now to save perf.
  let cardElements = document.querySelectorAll('.hero-card, .project-item, .contact-link, .back-link, .center-container h1');
  
  // Re-query occasionally or on intersection?
  // Let's just do it every frame for robust "moving" references if needed? 
  // Actually getBoundingClientRect is the heavy part.
  
  function animate() {
    if (!ctx) return;
    ctx.clearRect(0, 0, width, height);

    // Prepare repulsors list for this frame
    const repulsors = [];
    
    // 1. Mouse
    if (mouse.x > 0 && mouse.y > 0) {
        repulsors.push({
            x: mouse.x,
            y: mouse.y,
            radius: 150,
            strength: repulsionStrength
        });
    }

    // 2. Cards & Elements
    // Re-query if list empty (maybe loaded later) ?
    if (cardElements.length === 0) {
        cardElements = document.querySelectorAll('.hero-card, .project-item, .contact-link, .back-link, .center-container h1');
    }

    cardElements.forEach(el => {
        const rect = el.getBoundingClientRect();
        // Check if visible/relevant
        if (rect.bottom < 0 || rect.top > height || rect.width === 0) return;

        // Use a radius that covers the card nicely
        // Diagonal / 2 is exact, mostly.
        // let's use max dimension / 1.5 to have a "force field" around it
        const radius = Math.max(rect.width, rect.height) / 1.5;

        repulsors.push({
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
            radius: radius,
            strength: repulsionStrength
        });
    });
    
    stars.forEach(star => {
      star.update(repulsors);
      star.draw();
    });

    requestAnimationFrame(animate);
  }

  initStars();
  animate();
</script>
