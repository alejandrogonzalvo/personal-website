---
import StarsBackground from './StarsBackground.astro';
---

<section class="hero-section" id="hero">
    <StarsBackground />
    <video class="hero-bg" autoplay loop muted playsinline>
        <source src="/quvis-summary-optimized.mp4" type="video/mp4">
    </video>
	<div class="content">
        <div class="hero-card">
            <!-- Name Typewriter Container -->
            <h1 id="name-typewriter" class="one-line-title"></h1>
            
            <!-- Role Typewriter Container -->
            <h2 id="role-typewriter"></h2>
            
            <!-- Buttons container -->
            <div class="actions fade-in-buttons">
                <div class="btn-container">
                    <a href="/contact" class="btn primary contact-card">
                        <div class="btn-light"></div>
                        <span class="btn-text">Contact Me</span>
                    </a>
                </div>
            </div>
        </div>
	</div>
	
	<a href="#experience" class="scroll-down fade-in-scroll" id="scroll-hint" aria-label="Scroll down">
		<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
			<path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
		</svg>
	</a>
</section>

<script>
    // Handle Scroll Hint Fade Out
    const scrollHint = document.getElementById('scroll-hint');
    if (scrollHint) {
        window.addEventListener('scroll', () => {
            if (window.scrollY > 50) {
                scrollHint.style.opacity = '0';
                scrollHint.style.pointerEvents = 'none';
            } else {
                if (scrollHint.classList.contains('visible')) {
                    scrollHint.style.opacity = '1';
                    scrollHint.style.pointerEvents = 'auto';
                }
            }
        });
    }

    // Scroll-linked Background Effect
    const heroBg = document.querySelector('.hero-bg') as HTMLElement;
    if (heroBg) {
        window.addEventListener('scroll', () => {
            const scrollY = window.scrollY;
            const heroHeight = window.innerHeight;
            
            // Only animate if within relevant scroll range (e.g. 1 viewport height)
            if (scrollY <= heroHeight) {
                // Zoom out effect: Start at 1.25, end at 1
                const scale = 1.25 - (scrollY / heroHeight) * 0.25;
                
                // Blur effect: Start at 0, increase with scroll
                const blur = (scrollY / heroHeight) * 10;
                
                // Opacity effect: Fade out as we scroll
                // Max opacity is 0.3 (defined in CSS .hero-bg.visible)
                const maxOpacity = 0.3;
                const fadeProgress = Math.min(1, (scrollY / heroHeight) * 1.5);
                const opacity = Math.max(0, maxOpacity * (1 - fadeProgress));
                
                // If it hasn't faded in yet via the intro animation, don't force it.
                // We check if it has the 'visible' class which sets opacity: 1 (actually 0.3 in CSS)
                if (heroBg.classList.contains('visible')) {
                     heroBg.style.transform = `scale(${Math.max(1, scale)})`;
                     heroBg.style.filter = `blur(${blur}px)`;
                     heroBg.style.opacity = `${opacity}`;
                }
            }
        });
    }
</script>

<script>
  import Typewriter from 'typewriter-effect/dist/core';
  import { ANIMATION_ROOT_MARGIN } from '../config';

  // Check visit status (sessionStorage persists while tab is open)
  const hasVisited = sessionStorage.getItem('visited');

  // Lock scroll initially ONLY if first visit
  if (!hasVisited) {
      document.body.style.overflow = 'hidden';
      sessionStorage.setItem('visited', 'true');
  }

  const nameEl = document.getElementById('name-typewriter');
  const roleEl = document.getElementById('role-typewriter');
  // We need to cast to HTMLElement to access style
  const buttonsInfo = document.querySelectorAll('.fade-in-buttons');
  const heroBg = document.querySelector('.hero-bg');
  const heroCard = document.querySelector('.hero-card');

  // Shared Observer for all Hero elements
  const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
          if (entry.isIntersecting) {
              entry.target.classList.add('visible');
          } else {
              entry.target.classList.remove('visible');
          }
      });
  }, {
      threshold: 0.1,
      rootMargin: ANIMATION_ROOT_MARGIN
  });

  const observeElement = (el) => {
      if (!el) return;
      observer.observe(el);
      // If it's already in view (likely), the observer will trigger 'visible'
      // But for cleaner initial state if JS loads fast:
      // el.classList.add('visible'); // Let observer handle it to be safe/consistent
  };

  const showButtons = () => {
      // Unlock scroll
      document.body.style.overflow = 'auto';

      buttonsInfo.forEach(el => {
          observeElement(el);
      });
      // Handle scroll hit separately
      const scrollHint = document.getElementById('scroll-hint');
      if (scrollHint) scrollHint.classList.add('visible');

      // Handle Header fade-in
      const header = document.querySelector('header');
      if (header) header.classList.add('visible');
      
      // Handle Background fade-in
      if (heroBg) {
          heroBg.classList.add('visible');
      }

      // Handle Card Glass Effect Pop
      if (heroCard) {
          observeElement(heroCard);
      }
  };

  const nameTw = new Typewriter(nameEl, {
      delay: 50,
      cursor: '|', // Keep cursor while typing
  });

  const roleTw = new Typewriter(roleEl, {
      delay: 50,
      loop: true,
      autoStart: false,
      cursor: '|'
  });

  // Setup Role Sequence
  roleTw
      .typeString('Software Engineer')
      .callFunction(() => {
          // First string finished. Wait 0.5s then show buttons.
          // In visited mode this is redundant but harmless as they are already visible
          setTimeout(showButtons, 100);
      })
      .pauseFor(1500)
      .deleteAll()
      .typeString('Full Stack Developer')
      .pauseFor(1500)
      .deleteAll()
      .typeString('CERN Alumnus')
      .pauseFor(1500)
      .deleteAll()
      .typeString('Quantum Researcher')
      .pauseFor(1500)
      .deleteAll()
      .typeString('Triathlete')
      .pauseFor(1500)
      .deleteAll()
      .typeString('Gamer')
      .pauseFor(1500)
      .deleteAll();





  // Start Main Sequence
  // 1. Start observing h1 immediately so it appears
  observeElement(nameEl);

  if (hasVisited) {
      // VISITED MODE
      // 1. Show all static elements immediately
      showButtons();

      // 2. "Welcome back" -> Normal intro
      nameTw
        .typeString("Welcome back")
        .pauseFor(1500)
        .deleteAll()
        .pauseFor(200)
        .typeString("Hi")
        .pauseFor(500)
        .typeString(", I'm Alejandro")
        .pauseFor(500)
        .callFunction(() => {
            const cursor = nameEl.querySelector('.Typewriter__cursor');
            if (cursor) cursor.style.display = 'none';
            
            setTimeout(() => {
                observeElement(roleEl);
                roleTw.start();
            }, 100);
        })
        .start();

  } else {
      // FIRST VISIT MODE
      // Standard delayed sequence with scroll lock
      nameTw
        .typeString("Hi,")
        .pauseFor(500)
        .typeString(" I'm Alejandro")
        .pauseFor(500)
        .callFunction(() => {
            // Remove cursor from name after typing
            const cursor = nameEl.querySelector('.Typewriter__cursor');
            if (cursor) cursor.style.display = 'none';
            
            setTimeout(() => {
                // 2. Reveal h2 via observer
                observeElement(roleEl);
                roleTw.start();
            }, 100);
        })
        .start();
  }

  // Contact Button 3D Effect
  const btnContainer = document.querySelector('.btn-container') as HTMLElement;
  const contactCard = document.querySelector('.contact-card') as HTMLElement;

  if (btnContainer && contactCard) {
      const btnLight = contactCard.querySelector('.btn-light') as HTMLElement;
      
      let mouse = { x: 0, y: 0 };
      let target = { x: 0, y: 0, scale: 1, z: 0 };
      let current = { cx: 0, cy: 0, scale: 1, z: 0 };
      let isHovering = false;
      
      btnContainer.addEventListener('mouseenter', () => {
          isHovering = true;
      });

      btnContainer.addEventListener('mousemove', (e) => {
          isHovering = true;
          const rect = btnContainer.getBoundingClientRect();
          target.x = (e.clientX - rect.left) - rect.width / 2;
          target.y = (e.clientY - rect.top) - rect.height / 2;
          // target.scale = 1.05; // Subtle scale up
          target.z = 10;
          
          if (btnLight) {
               const lightX = e.clientX - rect.left;
               const lightY = e.clientY - rect.top;
               btnLight.style.background = `radial-gradient(circle at ${lightX}px ${lightY}px, rgba(255,255,255,0.2), transparent 100px)`;
               btnLight.style.opacity = '1';
          }
      });

      btnContainer.addEventListener('mouseleave', () => {
          isHovering = false;
          target.x = 0;
          target.y = 0;
          target.scale = 1;
          target.z = 0;
          
          if (btnLight) {
              btnLight.style.opacity = '0';
          }
      });

      const updateCard = () => {
        //   current.cx += (target.x - current.cx) / 5; // Faster response than projects
        //   current.cy += (target.y - current.cy) / 5;
        //   current.scale += (target.scale - current.scale) / 10;
        //   current.z += (target.z - current.z) / 10;

        current.cx += (target.x - current.cx) * 0.1;
        current.cy += (target.y - current.cy) * 0.1;
        current.scale += (target.scale - current.scale) * 0.1;

        // Idle float animation
        let tx = 0, ty = 0;
        if (!isHovering) {
            const time = Date.now() * 0.002;
            ty = Math.sin(time) * 5; // Float up and down 5px
        }

          // Apply transformations
          // Limit rotation to avoid too much tilt on small button
          // Add ty to translation
          contactCard.style.transform = `
              translate3d(${tx}px, ${ty}px, 0)
              scale(${current.scale}) 
              translateZ(${current.z}px)
              rotateX(${current.cy * 0.15}deg) 
              rotateY(${current.cx * 0.15}deg)
          `;
          
          requestAnimationFrame(updateCard);
      };
      
      updateCard();
  }

  // Hero Card 3D Effect implementation
  if (heroCard) {
      const card = heroCard as HTMLElement;
      let mouse = { x: 0, y: 0 };
      let target = { x: 0, y: 0, scale: 1, z: 0 };
      let current = { cx: 0, cy: 0, scale: 1, z: 0 };
      let isHovering = false;

      // Track scroll for parallax
      let lastScrollY = window.scrollY;
      window.addEventListener('scroll', () => { lastScrollY = window.scrollY; }, { passive: true });

      card.addEventListener('mouseenter', () => {
          isHovering = true;
      });

      card.addEventListener('mousemove', (e) => {
          isHovering = true;
          const rect = card.getBoundingClientRect();
          target.x = (e.clientX - rect.left) - rect.width / 2;
          target.y = (e.clientY - rect.top) - rect.height / 2;
          target.scale = 1.02; // Subtle scale up for the big card
          target.z = 5;
      });

      card.addEventListener('mouseleave', () => {
          isHovering = false;
          target.x = 0;
          target.y = 0;
          target.scale = 1;
          target.z = 0;
      });

      const updateHeroCard = () => {
          // Smooth interpolation
          current.cx += (target.x - current.cx) * 0.1;
          current.cy += (target.y - current.cy) * 0.1;
          current.scale += (target.scale - current.scale) * 0.1;

          // Progressive Parallax Calculation
          // Formula: 0.8 - (scrollY / (k * heroHeight))^2
          // Exponential drop-off keeps the factor higher (stickier) for longer,
          // then releases rapidly.
          const heroHeight = window.innerHeight;
          const k = 1; // Tunable constant for release speed
          
          const ratio = lastScrollY / (k * heroHeight);
          const parallaxFactor = 0.8 - Math.pow(ratio, 2.5);
          
          // Calculate Y translation
          const scrollTranslation = lastScrollY * parallaxFactor;

          // Apply transformations
          // using inverted Y axis as requested: cy * -0.01 (subtle rotation for large element)
          card.style.transform = `
              translate3d(0, ${scrollTranslation}px, 0)
              scale(${current.scale}) 
              perspective(1000px)
              rotateX(${current.cy * -0.02}deg) 
              rotateY(${current.cx * 0.02}deg)
          `;
          // card.style.opacity = `${opacity}`; // Removed opacity fade per user request

          requestAnimationFrame(updateHeroCard);
      };

      updateHeroCard();
  }

</script>

<style>
	.hero-section {
		height: 100vh; /* Force full screen height */
		width: 100%;
        display: flex;
		flex-direction: column;
		justify-content: center;
        align-items: center; /* Center horizontally */
		position: relative;
        /* overflow: hidden;  REMOVED to prevent clipping of sticky card */
        padding: 0 1rem;
        /* Ensure no margin interference */
        margin: 0 0 30vh 0;
        /* Removed radial-gradient per user request */
	}
    
    .hero-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1; /* Above stars */
        object-fit: cover;
        /* Start zoomed in */
        transform: scale(1.25);
        opacity: 0;
        /* Transition for fade-in */
        transition: opacity 2s ease-out;
        will-change: transform, filter, opacity;
        filter: blur(0px);
        pointer-events: none; /* Ensure clicks pass through */
    }
    
    .hero-bg.visible {
        opacity: 0.3; /* Max opacity - keep text readable */
    }


    
    .content {
        z-index: 10;
        width: 100%;
        max-width: 1000px;
        display: flex;
        justify-content: center;
        perspective: 1000px; /* Enable 3D perspective */
    }
    
    /* Hero Card (Glass Effect) */
    .hero-card {
        padding: 3rem;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: transparent; /* Initially transparent */
        backdrop-filter: none;
        border: 1px solid transparent;
        border-radius: 16px;
        /* transform-style: preserve-3d; Removed to fix backdrop-filter */
        
        /* Transition specific properties to avoid conflict with JS transform */
        transition: 
            background 1.5s cubic-bezier(0.16, 1, 0.3, 1),
            backdrop-filter 1.5s cubic-bezier(0.16, 1, 0.3, 1),
            border-color 1.5s cubic-bezier(0.16, 1, 0.3, 1),
            box-shadow 1.5s cubic-bezier(0.16, 1, 0.3, 1);
    }
    
    .hero-card.visible {
        background: rgba(0, 0, 0, 0.5); /* Dark overlay */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
    }

	h1 {
		font-size: 5rem;
		line-height: 1.1;
		font-weight: 800;
		margin-bottom: 0.5rem;
		letter-spacing: -0.02em;
        white-space: nowrap; 
        min-height: 1.1em;
        
        /* Animation */
        opacity: 0;
        transition: opacity 0.6s ease-out;
        will-change: opacity;
	}
    h1.visible {
        opacity: 1;
    }
    
	h2 {
		font-size: 2rem;
		color: var(--accent-color);
		font-weight: 600;
		margin-bottom: 3rem; /* Increased spacing */
		min-height: 2.5rem;
        
        /* Animation */
        opacity: 0; 
        transition: opacity 0.6s ease-out;
        will-change: opacity;
	}
    h2.visible {
        opacity: 1;
    }
	
	.actions {
		display: flex;
		gap: 1.5rem;
        justify-content: center;
	}
	
	/* Buttons & Scroll Hint Initial State */
	.fade-in-buttons {
		opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        visibility: hidden;
	}
    
    .fade-in-buttons.visible {
        opacity: 1;
        transform: translateY(0);
        visibility: visible;
    }
    
    .fade-in-scroll {
		opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        visibility: hidden;
    }
    
    .fade-in-scroll.visible {
        opacity: 1;
        transform: translateY(0);
        visibility: visible;
    }

    /* 3D Button Container */
    .btn-container {
        perspective: 500px;
        display: inline-block;
    }

	.btn {
		text-decoration: none;
		padding: 1rem 2rem;
		border-radius: 8px;
		font-weight: 500;
		/* transition: all 0.2s ease;  Removed standard transition for physics one */
		font-size: 1.1rem;
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transform-style: preserve-3d; /* Key for 3D effect */
	}
	.btn.primary {
		background: var(--text-primary);
		color: var(--bg-color);
        /* Simple shadow for depth */
        box-shadow: 0 4px 10px rgba(0,0,0,0.2); 
	}
	/* .btn.primary:hover {
		background: var(--text-secondary);
		transform: translateY(-2px);
	} REMOVE STANDARD HOVER */
	.btn.secondary {
		border: 1px solid var(--surface-color);
		color: var(--text-primary);
		background: var(--surface-color);
	}
	.btn.secondary:hover {
		border-color: var(--text-secondary);
		transform: translateY(-2px);
	}
    
    /* Lighting Effect */
    .btn-light {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        pointer-events: none;
        z-index: 2;
        opacity: 0;
        transition: opacity 0.2s;
        mix-blend-mode: overlay; /* Blends nicely with button color */
    }
    
    .btn-text {
        position: relative;
        z-index: 5;
        transform: translateZ(15px); /* Lift text */
        pointer-events: none;
    }
	
	.scroll-down {
		position: absolute;
        bottom: 2.5rem;
		left: 50%;
        transform: translateX(-50%);
		color: var(--text-secondary);
        cursor: pointer;
        transition: opacity 0.3s ease;
	}
    
    .scroll-down.visible {
        animation: bounce 2s infinite;
    }

	@keyframes bounce {
		0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);}
		40% {transform: translateX(-50%) translateY(-10px);}
		60% {transform: translateX(-50%) translateY(-5px);}
	}

	@media (max-width: 1024px) {
		h1 {
			font-size: 3.5rem;
		}
	}
    @media (max-width: 600px) {
        h1 {
            font-size: 2.2rem; 
        }
        h2 {
            font-size: 1.5rem;
        }
        .actions {
            flex-direction: column;
            width: 100%;
            max-width: 300px;
        }
        .btn {
            width: 100%;
            text-align: center;
        }
        .hero-card {
            padding: 2rem 1rem;
            width: 100%;
        }
        .content {
            padding: 0 0.5rem;
        }
    }
</style>
